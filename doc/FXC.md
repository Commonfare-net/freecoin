
# Scenario

SecretShare authentication in Freecoin is based on the Shamir Secret Sharing Scheme (SSSS).

We envision a scenario where we have three actors:

- Organization (minting and administering the currency)
- Participant (single individuals using the currency)
- Vendor (third-party providing value for the currency)

We want a situation in which one of these actors alone is not able to access the wallet, but at least the consent of two actors is necessary, where the most common case will be:

- Organization & Participant (to view funds, send and receive)
- Organization & Vendor (to redeem currency)

The last case, Participant & Vendor, will likely not occur in normal situations, but is a warranty that the funds will exist even if the Organization disappears.

# Implementation

This implementation is called "FXC protocol" and this is version 1.

The FXC passphrase is created by two random sequences, which are then split in 9 parts with quorum 5 using SSSS, the passphrase is then deleted and only the SSSS slices can be used to retrieve it: we call this a tuple, basically a 2x9 array of SSSS keys which are vertically associated.

Tuple example in slices

P = Participant
O = Organization
V = Vendor

         :HI        :LO
    FXC1_random_FXC_random - P     } cookie & backup

    FXC1_random_FXC_random - P     } backup
    FXC1_random_FXC_random - P     } backup

    FXC1_random_FXC_random - O & P } backup

    FXC1_random_FXC_random - O
    FXC1_random_FXC_random - O
    FXC1_random_FXC_random - O
    
    FXC1_random_FXC_random - V     } optional drop from server
    FXC1_random_FXC_random - V     } optional drop from server
    FXC1_random_FXC_random - V     } optional drop from server
    

The random is a long integer encoded using hashid using an alphabet that is fine tuned to not include any ambiguous character and eventually be
communicated between humans without the use of computers. The salt used to hashid encode is semi-secret and is communicated to all parties.

# Tokens

Every authenticated session should contain this information:

Session:

    {
        uuid:  string
        slice: string
    }

These values are either found as private cookies or generated by a signup process. The implementation is in secretshare.clj and auth.clj (WIP)

# Backup

The backup of authentication can be made saving users email and/or providing a QR code for print and cold storage

The QR will contain:

    {
        uuid: string
        slice-1: string
        slice-2: string
        slice-3: string
    }

# Workflow for participants

P = participant
O = Organization

`O <- P :` if valid cookie *login* else propose *signin* or *recover*

Signin:

`O -> P :` create NXT pass, slice it in a tuple, save in db, give new cookie, redirect to new wallet

Login:

`O -> P :` get the slice from cookie, rebuild NXT pass, access wallet

Recover:

`O <- P :` ask email
`O      :` create unique secret url ready to set cookie
`O -> P :` send secret url
`O <- P :` access url, get cookie, redirect to wallet access

# Insecure mode

Running in insecure mode means without the secretshare split of keys.

We may want to postpone all of the authentication above to implement a
simple authorization scheme to use with the first pilots.

Home:

`O <- P :` if valid cookie *access* else *login*, *signin* or *recover*

Signin:

`O -> P :` create NXT pass, save it in db, give new cookie, *access*

Login:

`O -> P :` get pass, retrieve NXT, *access*

Recover:

`O <- P :` give email address, check if in database

`O -> P :` create unique secret url to set cookie, send email

`O <- P :` access url, get cookie, redirect to wallet *access*

